###############################################################
#Imports
###############################################################

import random as rand

###############################################################
#Functions
###############################################################

####Base function for the LFSR
def lfsr(seed, stop, opt = None, test = False, first = False):

    """Function to generate a sequence of bits using a Linear Feedback Shift Register (LFSR),
    with the possibility to test the LFSR_17 and the 2**17-1 different values,
    and to see the last sequence generated by the LFSR as well as the set of all sequences generated by the LFSR.

    The function takes the seed as a list, the number of bits to generate, the option to choose between the LFSR_17 and the LFSR_25,
    The function returns the sequence of bits generated, the set of all sequences generated, and the last sequence generated.
    If opt = 'lfsr_17', then the lfsr used/created is the lfsr_17, if opt = 'lfsr_25', then the lfsr used/created is the lfsr_25,
    if opt = None, then the lfsr used/created is the one in the first example given in the subject."""

    ####initialize the list to store the generated bits
    lfsr_1 = seed[:]    ###so that copy doesn't modify the original list
    #print(lfsr_1)
    results = []
    seq = set()    ###initialize the set to store all sequence lists
    last_seq = []    ###initialize the list to store the last sequence
    
    test_value = 0  ###initialize the test value to return True of False if the sequence already exists when asked

    ####add 1 to the first bit of lfsrc_17 or lfsrc_25 if it is the start of CSS
    if first == True and (opt == 'lfsr_17' or opt == 'lfsr_25'):
        lfsr_1 = [1] + lfsr_1

    ####initialize the loop
    for i in range(int(stop)):
        #print("print", lfsr_1)
        results.append(lfsr_1[-1])
        
        if opt == None:
            seq.add(tuple(lfsr_1))
            xor = lfsr_1[-1] ^ lfsr_1[-3] ^ lfsr_1[-4] ^ lfsr_1[-5]    ###coefficients of the lfsr in the example given in the subject
            #print(xor)
            
        elif opt == 'lfsr_17':  ###lfsr_17 configuration
            xor = lfsr_1[-1] ^ lfsr_1[2]  ###coefficients of lfsrc_17  
            if test == True:    ###to test the lfsr_17 and the 2**17-1 different values
                if tuple(lfsr_1) in seq:
                    print("Sequence", lfsr_1, "already exists in the set!")
                    test_value += 1
                    break
            #print("print", lfsr_1)
            seq.add(tuple(lfsr_1))  ###to see the flow of sequences and configurations
            #print(seq)

        elif opt == 'lfsr_25':  ###lfsr_25 configuration
            xor = lfsr_1[-1] ^ lfsr_1[-4]^ lfsr_1[-5]^ lfsr_1[-13]  ###coefficients of lfsrc_17
            seq.add(tuple(lfsr_1))  ###to see the flow of sequences and configurations

        
        #print(lfsr_1)
        #print([xor], lfsr_1[:-1])
        lfsr_1 = [xor] + lfsr_1[:-1]    ###initialize the shift
        #print(lfsr_1)
    #print(results)

    if test == True and opt == 'lfsr_17' and test_value == 0:   ###to test the lfsr_17 and the 2**17-1 different values
        print(True)

    if i == stop - 1:    ###to store the last sequence
        last_seq = lfsr_1

    #print(last_seq)
    #print(len(last_seq))

    return results[::-1], seq, last_seq

####Function for CSS which uses of course the one for the LFSR
def css(suite, message):

    """Function to generate a cipher using the CSS (Complementary Sequence System) method,
    with the possibility to test the LFSR_17 and the LFSR_25.

    Takes suite the secret key as a list and message the message to encrypt in hexadecimal.
    Returns L, the list of each bytes z of the cipher in decimal."""

    s17 = suite[:16]    #take 16 bits for the lfsr_17
    s25 = suite[16:]    #take 24 bits for the lfsr_25
    #print(s17, s25)
    #print((s17 + s25) == suite)

    L = []
    c = 0
    m = int(message, 16)
    m = bin(m)[2:]
    #print(m)
    #print(len(m))
    length = len(m)

    for i in range (length):
        if i !=0:
            results_s17, _, last_seq_s17 = lfsr(last_seq_s17, 8, 'lfsr_17', test = False, first = False)
            results_s25, _, last_seq_s25 = lfsr(last_seq_s25, 8, 'lfsr_25', test = False, first = False)
        else:
            results_s17, _, last_seq_s17 = lfsr(s17, 8, 'lfsr_17', test = False, first = True)
            #print(results_s17, _, last_seq_s17)
            results_s25, _, last_seq_s25 = lfsr(s25, 8, 'lfsr_25', test = False, first = True)
            #print(results_s25, _, last_seq_s25)
        #print(results_s17, seq_s17, last_seq_s17)
        #print(results_s25, seq_s25, last_seq_s25)

        ####convert the results in integers
        s17 = int(''.join(str(bit) for bit in results_s17), 2) % 256    #%256 to have the value between 0 and 255
        s25 = int(''.join(str(bit) for bit in results_s25), 2) % 256    #%256 to have the value between 0 and 255

        ####convert sum of values and add the carry
        z = s17 + s25 + c
        L.append(z % 256)

        ####update the carry
        c = 1 if (s17 + s25) > 255 else 0
    return L

####Main function for the user to cipher with CSS
def CSS_User():

    """Main function for the user to cipher with CSS, the function asks the user to enter a message to encrypt in hexadecimal,
    the message is not checked so it's up to the user to give a proper hexadecimal.

    Takes nothing in argument, the function uses [0] * 40 as a secret as asked in the subject for Question 3.
    Returns the cipher in hexadecimal"""

    S = [0] * 40
    M = input("Enter the message to encrypt in hex: ").strip()  #delete spaces
    #M = '0xffffffffff'
    res = css(S, M)
    #print(res)
    #print(len(res))

    # Remove the prefix '0x' and split the string into pairs of hexadecimal digits
    M = M[2:]  # Remove the prefix '0x'
    M = [M[i:i+2] for i in range(0, len(M), 2)]  # Split the string into pairs of hexadecimal digits
    Cipher = [] 
    for i in range(len(M)):
        Cipher.append(hex(int(M[i], 16) ^ res[i])[2:].zfill(2))  #XOR operation, padding with zeroes if necessary

    return ''.join(Cipher)

####Main function for the user to decipher the CSS cipher
def Decipher_CSS_User():

    """Main function for the user to decipher the CSS cipher, the function asks the user to enter a cipher to decrypt in hexadecimal,
    the cipher is not checked so it's up to the user to give a proper hexadecimal that could be generated by CSS.

    Takes nothing in argument, the function uses [0] * 40 as a secret as asked in the subject for Question 3.
    Returns the message in hexadecimal"""

    S = [0] * 40
    C = input("Enter the cipher in hex: ").strip()  #delete spaces
    #C = '0xffffb66c39'
    res = css(S, C)
    #print(res)
    #print(len(res))

    # Remove the prefix '0x' and split the string into pairs of hexadecimal digits
    C = C[2:]  # Remove the prefix '0x'
    C = [C[i:i+2] for i in range(0, len(C), 2)]  # Split the string into pairs of hexadecimal digits
    Decipher = [] 
    for i in range(len(C)):
        Decipher.append(hex(int(C[i], 16) ^ res[i])[2:].zfill(2))    #XOR operation, padding with zeroes if necessary

    return ''.join(Decipher)


####Function to generate a random binary string of a given size, used for the attack
def generate_random_binary(size):

    """Function to generate a random binary string of a given size, used for the attack against the generator.
    
    Takes the size of the binary string to generate.
    Returns the random binary string with a 1 at the last position of the lfsr configuration."""
    
    # Generate a list of random 0s and 1s of the given size
    binary_list = [rand.choice([0, 1]) for _ in range(size)]
    
    #Add a 1 at the last position of the lfsr configuration
    #print("[1] + binary_list :",[1] + binary_list)
    print("len([1] + binary_list) :", len([1] + binary_list))
    return [1] + binary_list

####Attack against the generator
def attack():
    
    """Function to attack the generator and find the initial configurations of the two LFSR used in the CSS and the secret key used by the generator.
    It doesn't use the CSS function as it is, but uses the lfsr function to generate the sequences of bits and find the initial configurations of the two LFSR used in the CSS and the secret key used by generator.
    Not using CSS function was made for the sake simplicity and in order to have clean functions for each questions of the subject.
    
    Takes no argument but asks the first 6 bytes generated by CSS, returns the secret key of 40 bits used by the generator.
    Bytes aren't checked so be sure to enter proper bytes
    Returns the secret key of 40 bits used by the generator if found, if not then returns None."""

    #z1 = bin(int(input("Enter the first byte obtained from the CSS as a decimal number: ").strip()))[2:]  # Convert input to integer, get binary representation, and remove prefix '0b'
    #z2 = bin(int(input("Enter the second byte obtained from the CSS as a decimal number: ").strip()))[2:]  # Convert input to integer, get binary representation, and remove prefix '0b'
    #z3 = bin(int(input("Enter the third byte obtained from the CSS as a decimal number: ").strip()))[2:]  # Convert input to integer, get binary representation, and remove prefix '0b'
    #z4 = bin(int(input("Enter the fourth byte obtained from the CSS as a decimal number: ").strip()))[2:]  # Convert input to integer, get binary representation, and remove prefix '0b'
    #z5 = bin(int(input("Enter the fifth byte obtained from the CSS as a decimal number: ").strip()))[2:]  # Convert input to integer, get binary representation, and remove prefix '0b'
    #z6 = bin(int(input("Enter the sixth byte obtained from the CSS as a decimal number: ").strip()))[2:]  # Convert input to integer, get binary representation, and remove prefix '0b'
    #Bytes from Question 3 CSS
    z1 = "00000000"
    z2 = "00000000"
    z3 = "01001001"
    z4 = "10010011"
    z5 = "11000110"
    z6 = "11001001"
    Z = [z1, z2, z3, z4, z5, z6]
    
    ####Generate a random binary string of size 16
    test = 0
    previous_tries = set()
    while test < 2**16:
        if test % 1000 == 0:
            print("test numéro:", str(test))
        random_binary = generate_random_binary(16)
        
        if tuple(random_binary) in previous_tries:
            print("Sequence", random_binary, "already exists in the set! Trying another random binary...")
        else:
            previous_tries.add(tuple(random_binary))
            Y = []
            res_17 = []
            res_25 = []
            Z_guess = []
            c = 0
            for i in range (6):
                if i !=0:
                    results_s17, _, last_seq_s17 = lfsr(last_seq_s17, 8, 'lfsr_17', test = False, first = False)
                else:
                    results_s17, _, last_seq_s17 = lfsr(random_binary, 8, 'lfsr_17', test = False, first = False)
                #print("len last_seq_s17:", len(last_seq_s17))
                #print("len results_s17:", len(results_s17))

                ####convert the results in integers
                s17 = int(''.join(str(bit) for bit in results_s17), 2) % 256    #%256 to have the value between 0 and 255
                res_17.append(s17)
                #print("len res_17:", len(res_17))
                if i < 3:
                    y = (int(Z[i], 2) - s17 - c) % 256
                    c = 1 if (int(Z[i], 2) + s17) > 255 else 0
                    print(int(Z[i], 2) + s17)
                    Y.append(bin(y)[2:].zfill(8))   #padding with zeroes if necessary
                    print("Y:", Y)
                    #print("len Y:", len(Y))
                else:
                    pass
            Y = Y[::-1]
            Y = [int(bit) for binary in Y for bit in binary]
            s2_guess = [1] + Y
            print("s2_guess :", s2_guess)
            print("len s2_guess:", len(s2_guess))
            for i in range (6):
                if i !=0:
                    results_s25, _, last_seq_s25 = lfsr(last_seq_s25, 8, 'lfsr_25', test = False, first = False)
                else:
                    results_s25, _, last_seq_s25 = lfsr(s2_guess, 8, 'lfsr_25', test = False, first = False)
                s25 = int(''.join(str(bit) for bit in results_s25), 2) % 256    #%256 to have the value between 0 and 255
                res_25.append(s25)
            print("res_17", res_17)
            print("res_25", res_25)
            c = 0
            for i in range (2, -1, -1):
                z = res_17[-i] + res_25[-i] + c
                Z_guess.append(str(z % 256))

                ####update the carry
                c = 1 if (res_17[-i] + res_25[-i]) > 255 else 0 
            print("Z_guess", Z_guess)
            ####check if the guess is correct
            if str(int(Z[3],2)) == Z_guess[0] and str(int(Z[4],2)) == Z_guess[1] and str(int(Z[5],2)) == Z_guess[2]:
                print("Found the initial configuration of the LFSR:", random_binary)
                generator = random_binary[1:] + s2_guess[1:]
                test = 2**16
            else:
                print("Wrong guess! Trying another random binary...")
                test += 1
                generator = None
    return generator

###############################################################
#Tests & Verifications
###############################################################

###############To test the lfsr function
###to test with the example given in the subject
#results, seq, _ = lfsr([1, 0, 0, 1, 0, 1, 1, 0], 16)
#print(results, seq)
#print(len(seq))
###to test if the result is correct
#print([0,1,1,0,1,0,0,1,0,0,0,1,0,1,0,0] == results)

###to test the lfsr_17 and the 2**17-1 different values
#lfsr([1]*17, 2**17-1, 'lfsr_17', True)
#lfsr([1]*17, 140000, 'lfsr_17', True)
#lfsr([1]*17, 2**17, 'lfsr_17', True)

### to verify the configurations of the sequences
#results, seq, last_seq = lfsr([1]*17, 8, 'lfsr_17', True)
#print(results, seq, last_seq)
#print(len(seq))

###############To test the css function
#res = css([0] * 40, '0xffffffffff')
#print(res)
#print(len(res))

###############To test the random binary function
#random_binary = generate_random_binary(16)
#print(random_binary)
#print(len(random_binary))

###############To test the attack function and verify why it doesn't work
"""z1 = "10001100"
z2 = "10010111"
z3 = "10101101"
z4 = "10111010"
z5 = "11111011"
z6 = "11111100"
Z = [z1, z2, z3, z4, z5, z6]
Z_guess = ['186', '251', '252']
print (str(int(Z[3],2)) == Z_guess[0] and str(int(Z[4],2)) == Z_guess[1] and str(int(Z[5],2)) == Z_guess[2])"""

###############################################################
#Main
###############################################################

####Question 1
#elif opt == 'lfsr_17': in lfsr function, has to be in the parameter when calling the function
#To test the lfsr_17 and the 2**17-1 different values opt = 'lfsr_17' and test = True when calling the function
#lfsr([1]*17, 2**17-1, 'lfsr_17', True)
#lfsr([1]*17, 140000, 'lfsr_17', True)
#lfsr([1]*17, 2**17, 'lfsr_17', True)

####Question 2
#elif opt == 'lfsr_25': in lfsr function, has to be in the parameter when calling the function

####Question 3
#To test quickly with the subject's inputs, just add # before the input part and remove the one before the M = '0xffffffffff' and C = '0xffffb66c39'
#print(CSS_User())  
#print(Decipher_CSS_User())

####Question 4 & 5
#See PDF

####Question 6
print(attack())
#should work but the random function takes way too long to check all the possibilities for the initial state s1 as it has a tendency to generate the same sequence multiple times..
#the usage of multiple prints is to see the flow of the sequences and configurations and to try to debug the function
#the function currently can't find the initial configuration of the LFSR used in the CSS and the secret key used by the generator
#see README
